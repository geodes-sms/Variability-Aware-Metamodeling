-- FM2UMM.atl
-- Transform a Configured Feature Model (CFM) into a UMM
-- Traceability (μ : F → C) is embedded as an EAnnotation in each EClass



-- Metamodel declarations

-- @nsURI UMM = http://www.eclipse.org/emf/2002/Ecore
-- @nsURI FM = http://www.example.org/FM

module FM2UMM;
create OUT : UMM from IN : FM;


-- Rule 1: Root Feature
-- The root feature is transformed into the root class (non-abstract)

rule RootFeature2RootClass {
	from
		f : FM!RootFeature
	to
		c : UMM!EClass (
			name <- f.name,
			abstract <- false,
			eAnnotations <- Sequence {
				thisModule.Feature2Annotation(f)
			}
		)
}


-- Rule 2 & Rule 3: Concrete and Abstract Features
-- Each feature is transformed into a class with matching abstraction

rule Feature2Class {
    from
        f : FM!Feature (
            not f.oclIsTypeOf(FM!RootFeature)
        )
    to
        c : UMM!EClass (
            name <- f.name,
            abstract <- f.abstract,
            eAnnotations <- 
                Sequence { thisModule.Feature2Annotation(f) }
                ->union(
                    if f.isLeaf() then
                        Sequence { thisModule.LeafFeatureAnnotation(f)}
                    else
                        Sequence {}
                    endif
                ),
            eSuperTypes <- f.inheritsFrom()  -- now safe
        )
}


-- helper that returns a sequence of parent EClasses
helper context FM!Feature def : inheritsFrom() : Sequence(UMM!EClass) =
    FM!Association.allInstances()
            ->select(a | a.childfeature = self and a.parentfeature.abstract)
            ->collect(a | a.findParentClass());

lazy rule LeafParentAnnotationFromFeature { -- for leaf features we only add the parent as annotation for now
    from
        f : FM!Feature
    to
        a : UMM!EAnnotation (
            source <- 'FM2UMM',
            details <- Sequence {
                thisModule.ParentFeatureEntryFromFeature(f)
            }
        )
}

lazy rule ParentFeatureEntryFromFeature {
    from
        f : FM!Feature
    to
        e : UMM!EStringToStringMapEntry (
            key <- 'leafParent',
            value <- f.getAbstractParentName()  -- helper below
        )
}

helper context FM!Feature def : getAbstractParentName() : String =
    FM!Association.allInstances()
        ->select(a | a.childfeature = self and a.parentfeature.abstract)
        ->collect(a | a.parentfeature.name)
        ->first();  -- should be only one


-- Rule 4: Subfeature → Composition (Uncertainty on multiplicity), also Rule 8.1
-- Parent feature is concrete, child is not a leaf
rule SubFeature2Composition {
    from
        ass : FM!Association (
            not ass.parentfeature.abstract
        )
    to
        ref : UMM!EReference (
            name <- ass.childfeature.name.toLower(),
            eType <- ass.findChildClass(),
            containment <- true,
            lowerBound <- -2,
            upperBound <- -2
        )
    do {
        ass.findParentClass().eStructuralFeatures <- 
            ass.findParentClass().eStructuralFeatures->including(ref);
    }
}



-- Rule 5: Inheritance from Abstract Feature, also Rule 8.1
-- Child feature inherits from abstract parent feature 
lazy rule AddInheritance {
    from
        ass : FM!Association (
            ass.parentfeature.abstract
        )
    to
        c : UMM!EClass (
            -- only add inheritance if not leaf
            eSuperTypes <- Sequence { ass.findParentClass() },
            eAnnotations <- Sequence { thisModule.LeafParentAnnotation(ass) }
        )
}

lazy rule LeafParentAnnotation { -- nedeed later for Rule 8
    from
        ass : FM!Association
    to
        a : UMM!EAnnotation (
            source <- 'FM2UMM',
            details <- Sequence {
                thisModule.ParentFeatureEntry(ass)
            }
        )
}

lazy rule ParentFeatureEntry {
    from
        ass : FM!Association
    to
        e : UMM!EStringToStringMapEntry (
            key <- 'leafParent',
            value <- ass.parentfeature.name
        )
}



-- Rule 6: Leaf Feature Detection
-- A feature with no subfeatures introduces uncertainty

helper context FM!Feature def : isLeaf() : Boolean =
	FM!Association.allInstances()
		->select(a | a.parentfeature = self)
		->isEmpty();

lazy rule LeafFeatureAnnotation {
    from
        f : FM!Feature
    to
        a : UMM!EAnnotation (
            source <- 'FM2UMM',
            details <- Sequence {
                thisModule.FeatureLeafUncertainty(f)
            }
        )
}

lazy rule FeatureLeafUncertainty {
    from
        f : FM!Feature
    to
        e : UMM!EStringToStringMapEntry (
            key <- 'leaf',
            value <- 'true'
        )
}



-- Helper: Recover source feature name from class (μ⁻¹)
lazy rule Feature2Annotation {
    from
        f : FM!Feature
    to
        a : UMM!EAnnotation (
            source <- 'FM2UMM',
            details <- Sequence {
                thisModule.FeatureNameEntry(f)
            }
        )
}

lazy rule FeatureNameEntry {
    from
        f : FM!Feature
    to
        e : UMM!EStringToStringMapEntry (
            key <- 'feature',
            value <- f.name
        )
}

helper context UMM!EClass def : sourceFeatureName() : String =
	self.eAnnotations
		->select(a | a.source = 'FM2UMM')
		->first()
		.details->get('feature');


-- Helper: μ(F) → C using embedded trace

helper context FM!Feature def : targetClass() : UMM!EClass =
	UMM!EClass.allInstances()
		->select(c |
			c.eAnnotations->exists(a |
				a.source = 'FM2UMM' and
				a.details->get('feature') = self.name
			)
		)
		->first();


-- Helper: Association navigation using μ

helper context FM!Association def : findChildClass() : UMM!EClass =
	self.childfeature.targetClass();

helper context FM!Association def : findParentClass() : UMM!EClass =
	self.parentfeature.targetClass();
