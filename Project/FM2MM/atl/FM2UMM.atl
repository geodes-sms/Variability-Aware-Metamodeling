-- FM2MM.atl
-- Transform a Configured Feature Model (CFM) into a UMM
-- Traceability (μ : F → C) is embedded as an EAnnotation in each EClass



-- Metamodel declarations

-- @nsURI MM = http://www.eclipse.org/emf/2002/Ecore
-- @nsURI FM = http://www.example.org/FM

module FM2MM;
create OUT : MM from IN : FM;


-- Helper: Create trace annotation for μ(F) = C




-- Rule 1: Root Feature
-- The root feature is transformed into the root class (non-abstract)

rule RootFeature2RootClass {
	from
		f : FM!RootFeature
	to
		c : MM!EClass (
			name <- f.name,
			abstract <- false,
			eAnnotations <- Sequence {
				thisModule.featureTrace(f)
			}
		)
}


-- Rule 2 & Rule 3: Concrete and Abstract Features
-- Each feature is transformed into a class with matching abstraction

rule Feature2Class {
	from
		f : FM!Feature (
			not f.oclIsTypeOf(FM!RootFeature)
		)
	to
		c : MM!EClass (
			name <- f.name,
			abstract <- f.abstract,
			eAnnotations <- Sequence {
				thisModule.featureTrace(f)
			}
		)
}


-- Rule 4: Subfeature → Composition (Uncertainty on multiplicity)
-- Parent feature is concrete

rule SubFeature2Composition {
	from
		ass : FM!Association (
			not ass.parentfeature.abstract
		)
	to
		ref : MM!EReference (
			name <- ass.childfeature.name.toLower(),
			eType <- ass.findChildClass(),
			containment <- true,
			lowerBound <- 0,   -- ? unresolved multiplicity
			upperBound <- -1  -- ? unresolved multiplicity (*)
		)
	do {
		-- Attach reference to parent class
		ref.eContainingClass <- ass.findParentClass();
	}
}


-- Rule 5: Inheritance from Abstract Feature
-- Child feature inherits from abstract parent feature

rule AbstractParent2Inheritance {
	from
		ass : FM!Association (
			ass.parentfeature.abstract
		)
	to
		child : MM!EClass (
			eSuperTypes <- Sequence { ass.findParentClass() }
		)
}


-- Rule 6: Leaf Feature Detection
-- A feature with no subfeatures introduces uncertainty

helper context FM!Feature def : isLeaf() : Boolean =
	FM!Association.allInstances()
		->select(a | a.parentfeature = self)
		->isEmpty();


-- Rule 7: Multiplicity Resolution (Optional Helper)
-- Can be refined in later iterations

helper context FM!Association def : resolveMultiplicity()
	: TupleType(lower : Integer, upper : Integer) =
	if self.oclIsTypeOf(FM!OptionalAssociation) then
		Tuple { lower = 0, upper = 1 }
	else
		Tuple { lower = 1, upper = 1 }
	endif;


-- Rule 8.2: Leaf Feature → Enumeration
-- Alternative resolution for leaf features

rule LeafFeature2Enumeration {
	from
		f : FM!Feature (
			f.isLeaf() and not f.abstract
		)
	to
		e : MM!EEnum (
			name <- f.name.concat('Enum'),
			eLiterals <- Sequence {
				thisModule.createLiteral(f)
			}
		)
}


-- Helper: Create enumeration literal

rule Feature2EnumLiteral {
    from
        s : FM!Feature
    to
        t : MM!EEnumLiteral (
            name <- s.name.toUpper(),
            value <- 0
        )
}


-- Helper: Recover source feature name from class (μ⁻¹)

helper context MM!EClass def : sourceFeatureName() : String =
	self.eAnnotations
		->select(a | a.source = 'FM2MM')
		->first()
		.details->at('feature');


-- Helper: μ(F) → C using embedded trace

helper context FM!Feature def : targetClass() : MM!EClass =
	MM!EClass.allInstances()
		->select(c |
			c.eAnnotations->exists(a |
				a.source = 'FM2MM' and
				a.details->at('feature') = self.name
			)
		)
		->first();


-- Helper: Association navigation using μ

helper context FM!Association def : findChildClass() : MM!EClass =
	self.childfeature.targetClass();

helper context FM!Association def : findParentClass() : MM!EClass =
	self.parentfeature.targetClass();
